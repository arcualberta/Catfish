import { getCurrentInstance, inject, toRaw, watch, unref, markRaw, effectScope, ref, isVue2, isRef, isReactive, set, onUnmounted, reactive, toRef, del, nextTick, computed, toRefs } from "vue-demi"; import { setupDevtoolsPlugin } from "@vue/devtools-api"; let activePinia; const setActivePinia = e => activePinia = e, getActivePinia = () => getCurrentInstance() && inject(piniaSymbol) || activePinia, piniaSymbol = Symbol("pinia"); function isPlainObject(e) { return e && "object" == typeof e && "[object Object]" === Object.prototype.toString.call(e) && "function" != typeof e.toJSON } var MutationType; !function (e) { e.direct = "direct", e.patchObject = "patch object", e.patchFunction = "patch function" }(MutationType = MutationType || {}); const IS_CLIENT = "undefined" != typeof window, USE_DEVTOOLS = IS_CLIENT, _global = (() => "object" == typeof window && window.window === window ? window : "object" == typeof self && self.self === self ? self : "object" == typeof global && global.global === global ? global : "object" == typeof globalThis ? globalThis : { HTMLElement: null })(); function bom(e, { autoBom: t = !1 } = {}) { return t && /^\s*(?:text\/\S*|application\/xml|\S*\/\S*\+xml)\s*;.*charset\s*=\s*utf-8/i.test(e.type) ? new Blob([String.fromCharCode(65279), e], { type: e.type }) : e } function download(e, t, o) { const n = new XMLHttpRequest; n.open("GET", e), n.responseType = "blob", n.onload = function () { saveAs(n.response, t, o) }, n.onerror = function () { console.error("could not download file") }, n.send() } function corsEnabled(e) { const t = new XMLHttpRequest; t.open("HEAD", e, !1); try { t.send() } catch (e) { } return 200 <= t.status && t.status <= 299 } function click(t) { try { t.dispatchEvent(new MouseEvent("click")) } catch (e) { const o = document.createEvent("MouseEvents"); o.initMouseEvent("click", !0, !0, window, 0, 0, 0, 80, 20, !1, !1, !1, !1, 0, null), t.dispatchEvent(o) } } const _navigator = "object" == typeof navigator ? navigator : { userAgent: "" }, isMacOSWebView = (() => /Macintosh/.test(_navigator.userAgent) && /AppleWebKit/.test(_navigator.userAgent) && !/Safari/.test(_navigator.userAgent))(), saveAs = IS_CLIENT ? "undefined" != typeof HTMLAnchorElement && "download" in HTMLAnchorElement.prototype && !isMacOSWebView ? downloadSaveAs : "msSaveOrOpenBlob" in _navigator ? msSaveAs : fileSaverSaveAs : () => { }; function downloadSaveAs(e, t = "download", o) { const n = document.createElement("a"); n.download = t, n.rel = "noopener", "string" == typeof e ? (n.href = e, n.origin !== location.origin ? corsEnabled(n.href) ? download(e, t, o) : (n.target = "_blank", click(n)) : click(n)) : (n.href = URL.createObjectURL(e), setTimeout(function () { URL.revokeObjectURL(n.href) }, 4e4), setTimeout(function () { click(n) }, 0)) } function msSaveAs(e, t = "download", o) { if ("string" == typeof e) if (corsEnabled(e)) download(e, t, o); else { const n = document.createElement("a"); n.href = e, n.target = "_blank", setTimeout(function () { click(n) }) } else navigator.msSaveOrOpenBlob(bom(e, o), t) } function fileSaverSaveAs(e, t, o, n) { if ((n = n || open("", "_blank")) && (n.document.title = n.document.body.innerText = "downloading..."), "string" == typeof e) return download(e, t, o); t = "application/octet-stream" === e.type, o = /constructor/i.test(String(_global.HTMLElement)) || "safari" in _global; const a = /CriOS\/[\d]+/.test(navigator.userAgent); if ((a || t && o || isMacOSWebView) && "undefined" != typeof FileReader) { const i = new FileReader; i.onloadend = function () { let e = i.result; if ("string" != typeof e) throw n = null, new Error("Wrong reader.result type"); e = a ? e : e.replace(/^data:[^;]*;/, "data:attachment/file;"), n ? n.location.href = e : location.assign(e), n = null }, i.readAsDataURL(e) } else { const s = URL.createObjectURL(e); n ? n.location.assign(s) : location.href = s, n = null, setTimeout(function () { URL.revokeObjectURL(s) }, 4e4) } } function toastMessage(e, t) { e = "🍍 " + e; "function" == typeof __VUE_DEVTOOLS_TOAST__ ? __VUE_DEVTOOLS_TOAST__(e, t) : "error" === t ? console.error(e) : "warn" === t ? console.warn(e) : console.log(e) } function isPinia(e) { return "_a" in e && "install" in e } function checkClipboardAccess() { if (!("clipboard" in navigator)) return toastMessage("Your browser doesn't support the Clipboard API", "error"), !0 } function checkNotFocusedError(e) { return !!(e instanceof Error && e.message.toLowerCase().includes("document is not focused")) && (toastMessage('You need to activate the "Emulate a focused page" setting in the "Rendering" panel of devtools.', "warn"), !0) } async function actionGlobalCopyState(e) { if (!checkClipboardAccess()) try { await navigator.clipboard.writeText(JSON.stringify(e.state.value)), toastMessage("Global state copied to clipboard.") } catch (e) { if (checkNotFocusedError(e)) return; toastMessage("Failed to serialize the state. Check the console for more details.", "error"), console.error(e) } } async function actionGlobalPasteState(e) { if (!checkClipboardAccess()) try { e.state.value = JSON.parse(await navigator.clipboard.readText()), toastMessage("Global state pasted from clipboard.") } catch (e) { if (checkNotFocusedError(e)) return; toastMessage("Failed to deserialize the state from clipboard. Check the console for more details.", "error"), console.error(e) } } async function actionGlobalSaveState(e) { try { saveAs(new Blob([JSON.stringify(e.state.value)], { type: "text/plain;charset=utf-8" }), "pinia-state.json") } catch (e) { toastMessage("Failed to export the state as JSON. Check the console for more details.", "error"), console.error(e) } } let fileInput; function getFileOpener() { return fileInput || ((fileInput = document.createElement("input")).type = "file", fileInput.accept = ".json"), function () { return new Promise((o, e) => { fileInput.onchange = async () => { const e = fileInput.files; if (!e) return o(null); const t = e.item(0); return t ? o({ text: await t.text(), file: t }) : o(null) }, fileInput.oncancel = () => o(null), fileInput.onerror = e, fileInput.click() }) } } async function actionGlobalOpenStateFile(e) { try { const a = await getFileOpener(); var t = await a(); if (!t) return; var { text: o, file: n } = t; e.state.value = JSON.parse(o), toastMessage(`Global state imported from "${n.name}".`) } catch (e) { toastMessage("Failed to export the state as JSON. Check the console for more details.", "error"), console.error(e) } } function formatDisplay(e) { return { _custom: { display: e } } } const PINIA_ROOT_LABEL = "🍍 Pinia (root)", PINIA_ROOT_ID = "_root"; function formatStoreForInspectorTree(e) { return isPinia(e) ? { id: PINIA_ROOT_ID, label: PINIA_ROOT_LABEL } : { id: e.$id, label: e.$id } } function formatStoreForInspectorState(t) { if (isPinia(t)) { const o = Array.from(t._s.keys()), n = t._s, e = { state: o.map(e => ({ editable: !0, key: e, value: t.state.value[e] })), getters: o.filter(e => n.get(e)._getters).map(e => { const o = n.get(e); return { editable: !1, key: e, value: o._getters.reduce((e, t) => (e[t] = o[t], e), {}) } }) }; return e } const e = { state: Object.keys(t.$state).map(e => ({ editable: !0, key: e, value: t.$state[e] })) }; return t._getters && t._getters.length && (e.getters = t._getters.map(e => ({ editable: !1, key: e, value: t[e] }))), t._customProperties.size && (e.customProperties = Array.from(t._customProperties).map(e => ({ editable: !0, key: e, value: t[e] }))), e } function formatEventData(e) { return e ? Array.isArray(e) ? e.reduce((e, t) => (e.keys.push(t.key), e.operations.push(t.type), e.oldValue[t.key] = t.oldValue, e.newValue[t.key] = t.newValue, e), { oldValue: {}, keys: [], operations: [], newValue: {} }) : { operation: formatDisplay(e.type), key: formatDisplay(e.key), oldValue: e.oldValue, newValue: e.newValue } : {} } function formatMutationType(e) { switch (e) { case MutationType.direct: return "mutation"; case MutationType.patchFunction: case MutationType.patchObject: return "$patch"; default: return "unknown" } } let isTimelineActive = !0; const componentStateTypes = [], MUTATIONS_LAYER_ID = "pinia:mutations", INSPECTOR_ID = "pinia", getStoreType = e => "🍍 " + e; function registerPiniaDevtools(a, i) {
    setupDevtoolsPlugin({ id: "dev.esm.pinia", label: "Pinia 🍍", logo: "https://pinia.vuejs.org/logo.svg", packageName: "pinia", homepage: "https://pinia.vuejs.org", componentStateTypes: componentStateTypes, app: a }, e => {
        "function" != typeof e.now && toastMessage("You seem to be using an outdated version of Vue Devtools. Are you still using the Beta release instead of the stable one? You can find the links at https://devtools.vuejs.org/guide/installation.html."), e.addTimelineLayer({ id: MUTATIONS_LAYER_ID, label: "Pinia 🍍", color: 15064968 }), e.addInspector({ id: INSPECTOR_ID, label: "Pinia 🍍", icon: "storage", treeFilterPlaceholder: "Search stores", actions: [{ icon: "content_copy", action: () => { actionGlobalCopyState(i) }, tooltip: "Serialize and copy the state" }, { icon: "content_paste", action: async () => { await actionGlobalPasteState(i), e.sendInspectorTree(INSPECTOR_ID), e.sendInspectorState(INSPECTOR_ID) }, tooltip: "Replace the state with the content of your clipboard" }, { icon: "save", action: () => { actionGlobalSaveState(i) }, tooltip: "Save the state as a JSON file" }, { icon: "folder_open", action: async () => { await actionGlobalOpenStateFile(i), e.sendInspectorTree(INSPECTOR_ID), e.sendInspectorState(INSPECTOR_ID) }, tooltip: "Import the state from a JSON file" }], nodeActions: [{ icon: "restore", tooltip: "Reset the state (option store only)", action: e => { const t = i._s.get(e); t ? t._isOptionsAPI ? (t.$reset(), toastMessage(`Store "${e}" reset.`)) : toastMessage(`Cannot reset "${e}" store because it's a setup store.`, "warn") : toastMessage(`Cannot reset "${e}" store because it wasn't found.`, "warn") } }] }), e.on.inspectComponent((e, t) => { var o = e.componentInstance && e.componentInstance.proxy; o && o._pStores && (o = e.componentInstance.proxy._pStores, Object.values(o).forEach(n => { e.instanceData.state.push({ type: getStoreType(n.$id), key: "state", editable: !0, value: n._isOptionsAPI ? { _custom: { value: toRaw(n.$state), actions: [{ icon: "restore", tooltip: "Reset the state of this store", action: () => n.$reset() }] } } : Object.keys(n.$state).reduce((e, t) => (e[t] = n.$state[t], e), {}) }), n._getters && n._getters.length && e.instanceData.state.push({ type: getStoreType(n.$id), key: "getters", editable: !1, value: n._getters.reduce((t, o) => { try { t[o] = n[o] } catch (e) { t[o] = e } return t }, {}) }) })) }), e.on.getInspectorTree(t => { if (t.app === a && t.inspectorId === INSPECTOR_ID) { let e = [i]; e = e.concat(Array.from(i._s.values())), t.rootNodes = (t.filter ? e.filter(e => ("$id" in e ? e.$id : PINIA_ROOT_LABEL).toLowerCase().includes(t.filter.toLowerCase())) : e).map(formatStoreForInspectorTree) } }), e.on.getInspectorState(e => { var t; e.app === a && e.inspectorId === INSPECTOR_ID && (t = e.nodeId === PINIA_ROOT_ID ? i : i._s.get(e.nodeId)) && (e.state = formatStoreForInspectorState(t)) }), e.on.editInspectorState((e, t) => { if (e.app === a && e.inspectorId === INSPECTOR_ID) { const o = e.nodeId === PINIA_ROOT_ID ? i : i._s.get(e.nodeId); if (!o) return toastMessage(`store "${e.nodeId}" not found`, "error"); const n = e["path"]; isPinia(o) ? n.unshift("state") : (1 !== n.length || !o._customProperties.has(n[0]) || n[0] in o.$state) && n.unshift("$state"), isTimelineActive = !1, e.set(o, n, e.state.value), isTimelineActive = !0 } }), e.on.editComponentState(e => {
            if (e.type.startsWith("🍍")) {
                var t = e.type.replace(/^🍍\s*/, ""), o = i._s.get(t); if (!o) return toastMessage(`store "${t}" not found`, "error"); const n = e["path"]; if ("state" !== n[0]) return toastMessage(`Invalid path for store "${t}":
${n}
Only state can be modified.`); n[0] = "$state", isTimelineActive = !1, e.set(o, n, e.state.value), isTimelineActive = !0
            }
        })
    })
} function addStoreToDevtools(e, r) { componentStateTypes.includes(getStoreType(r.$id)) || componentStateTypes.push(getStoreType(r.$id)), setupDevtoolsPlugin({ id: "dev.esm.pinia", label: "Pinia 🍍", logo: "https://pinia.vuejs.org/logo.svg", packageName: "pinia", homepage: "https://pinia.vuejs.org", componentStateTypes: componentStateTypes, app: e, settings: { logStoreChanges: { label: "Notify about new/deleted stores", type: "boolean", defaultValue: !0 } } }, i => { const s = "function" == typeof i.now ? i.now.bind(i) : Date.now, t = (r.$onAction(({ after: e, onError: t, name: o, args: n }) => { const a = runningActionId++; i.addTimelineEvent({ layerId: MUTATIONS_LAYER_ID, event: { time: s(), title: "🛫 " + o, subtitle: "start", data: { store: formatDisplay(r.$id), action: formatDisplay(o), args: n }, groupId: a } }), e(e => { activeAction = void 0, i.addTimelineEvent({ layerId: MUTATIONS_LAYER_ID, event: { time: s(), title: "🛬 " + o, subtitle: "end", data: { store: formatDisplay(r.$id), action: formatDisplay(o), args: n, result: e }, groupId: a } }) }), t(e => { activeAction = void 0, i.addTimelineEvent({ layerId: MUTATIONS_LAYER_ID, event: { time: s(), logType: "error", title: "💥 " + o, subtitle: "end", data: { store: formatDisplay(r.$id), action: formatDisplay(o), args: n, error: e }, groupId: a } }) }) }, !0), r._customProperties.forEach(o => { watch(() => unref(r[o]), (e, t) => { i.notifyComponentUpdate(), i.sendInspectorState(INSPECTOR_ID), isTimelineActive && i.addTimelineEvent({ layerId: MUTATIONS_LAYER_ID, event: { time: s(), title: "Change", subtitle: o, data: { newValue: e, oldValue: t }, groupId: activeAction } }) }, { deep: !0 }) }), r.$subscribe(({ events: e, type: t }, o) => { if (i.notifyComponentUpdate(), i.sendInspectorState(INSPECTOR_ID), isTimelineActive) { const n = { time: s(), title: formatMutationType(t), data: { store: formatDisplay(r.$id), ...formatEventData(e) }, groupId: activeAction }; activeAction = void 0, t === MutationType.patchFunction ? n.subtitle = "⤵️" : t === MutationType.patchObject ? n.subtitle = "🧩" : e && !Array.isArray(e) && (n.subtitle = e.type), e && (n.data["rawEvent(s)"] = { _custom: { display: "DebuggerEvent", type: "object", tooltip: "raw DebuggerEvent[]", value: e } }), i.addTimelineEvent({ layerId: MUTATIONS_LAYER_ID, event: n }) } }, { detached: !0, flush: "sync" }), r._hotUpdate), e = (r._hotUpdate = markRaw(e => { t(e), i.addTimelineEvent({ layerId: MUTATIONS_LAYER_ID, event: { time: s(), title: "🔥 " + r.$id, subtitle: "HMR update", data: { store: formatDisplay(r.$id), info: formatDisplay("HMR update") } } }), i.notifyComponentUpdate(), i.sendInspectorTree(INSPECTOR_ID), i.sendInspectorState(INSPECTOR_ID) }), r)["$dispose"]; r.$dispose = () => { e(), i.notifyComponentUpdate(), i.sendInspectorTree(INSPECTOR_ID), i.sendInspectorState(INSPECTOR_ID), i.getSettings().logStoreChanges && toastMessage(`Disposed "${r.$id}" store 🗑`) }, i.notifyComponentUpdate(), i.sendInspectorTree(INSPECTOR_ID), i.sendInspectorState(INSPECTOR_ID), i.getSettings().logStoreChanges && toastMessage(`"${r.$id}" store installed 🆕`) }) } let runningActionId = 0, activeAction; function patchActionForGrouping(o, e) { const n = e.reduce((e, t) => (e[t] = toRaw(o)[t], e), {}); for (const a in n) o[a] = function () { const t = runningActionId; var e = new Proxy(o, { get(...e) { return activeAction = t, Reflect.get(...e) }, set(...e) { return activeAction = t, Reflect.set(...e) } }); return n[a].apply(e, arguments) } } function devtoolsPlugin({ app: e, store: t, options: o }) { if (!t.$id.startsWith("__hot:")) { if (o.state && (t._isOptionsAPI = !0), "function" == typeof o.state) { patchActionForGrouping(t, Object.keys(o.actions)); const n = t._hotUpdate; toRaw(t)._hotUpdate = function (e) { n.apply(this, arguments), patchActionForGrouping(t, Object.keys(e._hmrPayload.actions)) } } addStoreToDevtools(e, t) } } function createPinia() { const e = effectScope(!0); var t = e.run(() => ref({})); let o = [], n = []; const a = markRaw({ install(e) { setActivePinia(a), isVue2 || ((a._a = e).provide(piniaSymbol, a), e.config.globalProperties.$pinia = a, USE_DEVTOOLS && registerPiniaDevtools(e, a), n.forEach(e => o.push(e)), n = []) }, use(e) { return (this._a || isVue2 ? o : n).push(e), this }, _p: o, _a: null, _e: e, _s: new Map, state: t }); return USE_DEVTOOLS && "undefined" != typeof Proxy && a.use(devtoolsPlugin), a } const isUseStore = e => "function" == typeof e && "string" == typeof e.$id; function patchObject(e, t) { for (const a in t) { var o, n = t[a]; a in e && (isPlainObject(o = e[a]) && isPlainObject(n) && !isRef(n) && !isReactive(n) ? e[a] = patchObject(o, n) : isVue2 ? set(e, a, n) : e[a] = n) } return e } function acceptHMRUpdate(i, s) { return e => { const t = s.data.pinia || i._pinia; if (t) { s.data.pinia = t; for (const n in e) { const a = e[n]; if (isUseStore(a) && t._s.has(a.$id)) { var o = a.$id; if (o !== i.$id) return console.warn(`The id of the store changed from "${i.$id}" to "${o}". Reloading.`), s.invalidate(); o = t._s.get(o); if (!o) return void console.log("[Pinia]: skipping hmr because store doesn't exist yet"); a(t, o) } } } } } const noop = () => { }; function addSubscription(t, o, e, n = noop) { t.push(o); var a = () => { var e = t.indexOf(o); -1 < e && (t.splice(e, 1), n()) }; return !e && getCurrentInstance() && onUnmounted(a), a } function triggerSubscriptions(e, ...t) { e.slice().forEach(e => { e(...t) }) } function mergeReactiveObjects(e, t) { for (const a in t) { var o, n; t.hasOwnProperty(a) && (o = t[a], isPlainObject(n = e[a]) && isPlainObject(o) && e.hasOwnProperty(a) && !isRef(o) && !isReactive(o) ? e[a] = mergeReactiveObjects(n, o) : e[a] = o) } return e } const skipHydrateSymbol = Symbol("pinia:skipHydration"), skipHydrateMap = new WeakMap; function skipHydrate(e) { return isVue2 ? skipHydrateMap.set(e, 1) && e : Object.defineProperty(e, skipHydrateSymbol, {}) } function shouldHydrate(e) { return isVue2 ? !skipHydrateMap.has(e) : !isPlainObject(e) || !e.hasOwnProperty(skipHydrateSymbol) } const assign = Object["assign"]; function isComputed(e) { return !(!isRef(e) || !e.effect) } function createOptionsStore(n, e, a, t) { const { state: i, actions: s, getters: r } = e, c = a.state.value[n]; let o; return (o = createSetupStore(n, function () { c || t || (isVue2 ? set(a.state.value, n, i ? i() : {}) : a.state.value[n] = i ? i() : {}); const o = toRefs(t ? ref(i ? i() : {}).value : a.state.value[n]); return assign(o, s, Object.keys(r || {}).reduce((e, t) => (t in o && console.warn(`[🍍]: A getter cannot have the same name as another state property. Rename one of them. Found with "${t}" in store "${n}".`), e[t] = markRaw(computed(() => { setActivePinia(a); var e = a._s.get(n); if (!isVue2 || e._r) return r[t].call(e, e) })), e), {})) }, e, a, t, !0)).$reset = function () { const t = i ? i() : {}; this.$patch(e => { assign(e, t) }) }, o } function createSetupStore(s, e, t = {}, r, o, c) { let a; const n = assign({ actions: {} }, t); if (!r._e.active) throw new Error("Pinia destroyed"); const i = { deep: !0 }; isVue2 || (i.onTrigger = e => { l ? f = e : 0 != l || b._hotUpdating || (Array.isArray(f) ? f.push(e) : console.error("🍍 debuggerEvents should be an array. This is most likely an internal Pinia bug.")) }); let l, p, u = markRaw([]), d = markRaw([]), f; var y = r.state.value[s]; c || y || o || (isVue2 ? set(r.state.value, s, {}) : r.state.value[s] = {}); const g = ref({}); let h; function m(e) { let t; l = p = !1, f = [], t = "function" == typeof e ? (e(r.state.value[s]), { type: MutationType.patchFunction, storeId: s, events: f }) : (mergeReactiveObjects(r.state.value[s], e), { type: MutationType.patchObject, payload: e, storeId: s, events: f }); const o = h = Symbol(); nextTick().then(() => { h === o && (l = !0) }), p = !0, triggerSubscriptions(u, t, r.state.value[s]) } function v(a, i) { return function () { setActivePinia(r); var e = Array.from(arguments); const t = [], o = []; triggerSubscriptions(d, { args: e, name: a, store: b, after: function (e) { t.push(e) }, onError: function (e) { o.push(e) } }); let n; try { n = i.apply(this && this.$id === s ? this : b, e) } catch (e) { throw triggerSubscriptions(o, e), e } return n instanceof Promise ? n.then(e => (triggerSubscriptions(t, e), e)).catch(e => (triggerSubscriptions(o, e), Promise.reject(e))) : (triggerSubscriptions(t, n), n) } } const S = markRaw({ actions: {}, getters: {}, state: [], hotState: g }), _ = { _p: r, $id: s, $onAction: addSubscription.bind(null, d), $patch: m, $reset: () => { throw new Error(`🍍: Store "${s}" is built using the setup syntax and does not implement $reset().`) }, $subscribe(t, o = {}) { var e = addSubscription(u, t, o.detached, () => n()); const n = a.run(() => watch(() => r.state.value[s], e => { ("sync" === o.flush ? p : l) && t({ storeId: s, type: MutationType.direct, events: f }, e) }, assign({}, i, o))); return e }, $dispose: function () { a.stop(), u = [], d = [], r._s.delete(s) } }, b = (isVue2 && (_._r = !1), reactive(assign(IS_CLIENT ? { _customProperties: markRaw(new Set), _hmrPayload: S } : {}, _))), I = (r._s.set(s, b), r._e.run(() => (a = effectScope()).run(() => e()))); for (const O in I) { const w = I[O]; if (isRef(w) && !isComputed(w) || isReactive(w)) o ? set(g.value, O, toRef(I, O)) : c || (y && shouldHydrate(w) && (isRef(w) ? w.value = y[O] : mergeReactiveObjects(w, y[O])), isVue2 ? set(r.state.value[s], O, w) : r.state.value[s][O] = w), S.state.push(O); else if ("function" == typeof w) { var T = o ? w : v(O, w); isVue2 ? set(I, O, T) : I[O] = T, S.actions[O] = w, n.actions[O] = w } else if (isComputed(w) && (S.getters[O] = c ? t.getters[O] : w, IS_CLIENT)) { const P = I._getters || (I._getters = markRaw([])); P.push(O) } } isVue2 ? Object.keys(I).forEach(e => { set(b, e, I[e]) }) : (assign(b, I), assign(toRaw(b), I)), Object.defineProperty(b, "$state", { get: () => o ? g.value : r.state.value[s], set: t => { if (o) throw new Error("cannot set hotState"); m(e => { assign(e, t) }) } }); { b._hotUpdate = markRaw(n => { b._hotUpdating = !0, n._hmrPayload.state.forEach(e => { var t, o; e in b.$state && (t = n.$state[e], o = b.$state[e], "object" == typeof t && isPlainObject(t) && isPlainObject(o) ? patchObject(t, o) : n.$state[e] = o), set(b, e, toRef(n.$state, e)) }), Object.keys(b.$state).forEach(e => { e in n.$state || del(b, e) }), l = !1, p = !1, r.state.value[s] = toRef(n._hmrPayload, "hotState"), p = !0, nextTick().then(() => { l = !0 }); for (const o in n._hmrPayload.actions) { var e = n[o]; set(b, o, v(o, e)) } for (const a in n._hmrPayload.getters) { const i = n._hmrPayload.getters[a]; var t = c ? computed(() => (setActivePinia(r), i.call(b, b))) : i; set(b, a, t) } Object.keys(b._hmrPayload.getters).forEach(e => { e in n._hmrPayload.getters || del(b, e) }), Object.keys(b._hmrPayload.actions).forEach(e => { e in n._hmrPayload.actions || del(b, e) }), b._hmrPayload = n._hmrPayload, b._getters = n._getters, b._hotUpdating = !1 }); const A = { writable: !0, configurable: !0, enumerable: !1 }; IS_CLIENT && ["_p", "_hmrPayload", "_getters", "_customProperties"].forEach(e => { Object.defineProperty(b, e, { value: b[e], ...A }) }) } return isVue2 && (b._r = !0), r._p.forEach(e => { var t; IS_CLIENT ? (t = a.run(() => e({ store: b, app: r._a, pinia: r, options: n })), Object.keys(t || {}).forEach(e => b._customProperties.add(e)), assign(b, t)) : assign(b, a.run(() => e({ store: b, app: r._a, pinia: r, options: n }))) }), b.$state && "object" == typeof b.$state && "function" == typeof b.$state.constructor && !b.$state.constructor.toString().includes("[native code]") && console.warn('[🍍]: The "state" must be a plain object. It cannot be\n\tstate: () => new MyClass()\n' + `Found in store "${b.$id}".`), y && c && t.hydrate && t.hydrate(b.$state, y), l = !0, p = !0, b } function defineStore(e, c, t) { let l, p; const u = "function" == typeof c; function d(e, t) { var o = getCurrentInstance(); if ((e = e || o && inject(piniaSymbol)) && setActivePinia(e), !activePinia) throw new Error("[🍍]: getActivePinia was called with no active Pinia. Did you forget to install pinia?\n\tconst pinia = createPinia()\n\tapp.use(pinia)\nThis will fail in production."); (e = activePinia)._s.has(l) || (u ? createSetupStore(l, c, p, e) : createOptionsStore(l, p, e), d._pinia = e); var n, a, i = e._s.get(l); if (t && (n = "__hot:" + l, a = u ? createSetupStore(n, c, p, e, !0) : createOptionsStore(n, assign({}, p), e, !0), t._hotUpdate(a), delete e.state.value[n], e._s.delete(n)), IS_CLIENT && o && o.proxy && !t) { const s = o.proxy, r = "_pStores" in s ? s._pStores : s._pStores = {}; r[l] = i } return i } return "string" == typeof e ? (l = e, p = u ? t : c) : (p = e, l = e.id), d.$id = l, d } let mapStoreSuffix = "Store"; function setMapStoreSuffix(e) { mapStoreSuffix = e } function mapStores(...e) { return Array.isArray(e[0]) && (console.warn('[🍍]: Directly pass all stores to "mapStores()" without putting them in an array:\nReplace\n\tmapStores([useAuthStore, useCartStore])\nwith\n\tmapStores(useAuthStore, useCartStore)\nThis will fail in production if not fixed.'), e = e[0]), e.reduce((e, t) => (e[t.$id + mapStoreSuffix] = function () { return t(this.$pinia) }, e), {}) } function mapState(n, a) { return Array.isArray(a) ? a.reduce((e, t) => (e[t] = function () { return n(this.$pinia)[t] }, e), {}) : Object.keys(a).reduce((e, o) => (e[o] = function () { var e = n(this.$pinia); const t = a[o]; return "function" == typeof t ? t.call(this, e) : e[t] }, e), {}) } const mapGetters = mapState; function mapActions(o, n) { return Array.isArray(n) ? n.reduce((e, t) => (e[t] = function (...e) { return o(this.$pinia)[t](...e) }, e), {}) : Object.keys(n).reduce((e, t) => (e[t] = function (...e) { return o(this.$pinia)[n[t]](...e) }, e), {}) } function mapWritableState(o, n) { return Array.isArray(n) ? n.reduce((e, t) => (e[t] = { get() { return o(this.$pinia)[t] }, set(e) { return o(this.$pinia)[t] = e } }, e), {}) : Object.keys(n).reduce((e, t) => (e[t] = { get() { return o(this.$pinia)[n[t]] }, set(e) { return o(this.$pinia)[n[t]] = e } }, e), {}) } function storeToRefs(e) { if (isVue2) return toRefs(e); { const o = {}; for (const n in e = toRaw(e)) { var t = e[n]; (isRef(t) || isReactive(t)) && (o[n] = toRef(e, n)) } return o } } const PiniaVuePlugin = function (e) { e.mixin({ beforeCreate() { var e = this.$options; if (e.pinia) { const t = e.pinia; if (!this._provided) { const o = {}; Object.defineProperty(this, "_provided", { get: () => o, set: e => Object.assign(o, e) }) } this._provided[piniaSymbol] = t, this.$pinia || (this.$pinia = t), t._a = this, IS_CLIENT && setActivePinia(t), USE_DEVTOOLS && registerPiniaDevtools(t._a, t) } else !this.$pinia && e.parent && e.parent.$pinia && (this.$pinia = e.parent.$pinia) }, destroyed() { delete this._pStores } }) }; export { MutationType, PiniaVuePlugin, acceptHMRUpdate, createPinia, defineStore, getActivePinia, mapActions, mapGetters, mapState, mapStores, mapWritableState, setActivePinia, setMapStoreSuffix, skipHydrate, storeToRefs };