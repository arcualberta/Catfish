var Pinia = function (g, R) { "use strict"; let l; const P = t => l = t, d = Symbol(); function w(t) { return t && "object" == typeof t && "[object Object]" === Object.prototype.toString.call(t) && "function" != typeof t.toJSON } g.MutationType = void 0, (e = g.MutationType || (g.MutationType = {})).direct = "direct", e.patchObject = "patch object", e.patchFunction = "patch function"; const n = "undefined" != typeof window, S = () => { }; function V(e, n, t, i = S) { e.push(n); var r = () => { var t = e.indexOf(n); -1 < t && (e.splice(t, 1), i()) }; return !t && R.getCurrentInstance() && R.onUnmounted(r), r } function k(t, ...e) { t.slice().forEach(t => { t(...e) }) } function A(t, e) { for (const r in e) { var n, i; e.hasOwnProperty(r) && (n = e[r], i = t[r], t[r] = w(i) && w(n) && t.hasOwnProperty(r) && !R.isRef(n) && !R.isReactive(n) ? A(i, n) : n) } return t } const M = Symbol(), T = new WeakMap, I = Object["assign"]; function y(a, t, e = {}, o, n, i) { let r; const s = I({ actions: {} }, e), c = { deep: !0 }; let u, p, f, h = R.markRaw([]), l = R.markRaw([]); var d = o.state.value[a]; let y; function v(t) { let e; u = p = !1, e = "function" == typeof t ? (t(o.state.value[a]), { type: g.MutationType.patchFunction, storeId: a, events: f }) : (A(o.state.value[a], t), { type: g.MutationType.patchObject, payload: t, storeId: a, events: f }); const n = y = Symbol(); R.nextTick().then(() => { y === n && (u = !0) }), p = !0, k(h, e, o.state.value[a]) } i || d || (R.isVue2 ? R.set(o.state.value, a, {}) : o.state.value[a] = {}), R.ref({}); var $, b = S; function _(r, s) { return function () { P(o); const t = Array.from(arguments), e = [], n = []; let i; k(l, { args: t, name: r, store: m, after: function (t) { e.push(t) }, onError: function (t) { n.push(t) } }); try { i = s.apply(this && this.$id === a ? this : m, t) } catch (t) { throw k(n, t), t } return i instanceof Promise ? i.then(t => (k(e, t), t)).catch(t => (k(n, t), Promise.reject(t))) : (k(e, i), i) } } const j = { _p: o, $id: a, $onAction: V.bind(null, l), $patch: v, $reset: b, $subscribe(e, n = {}) { const t = V(h, e, n.detached, () => i()), i = r.run(() => R.watch(() => o.state.value[a], t => { ("sync" === n.flush ? p : u) && e({ storeId: a, type: g.MutationType.direct, events: f }, t) }, I({}, c, n))); return t }, $dispose: function () { r.stop(), h = [], l = [], o._s.delete(a) } }, m = (R.isVue2 && (j._r = !1), R.reactive(I({}, j))), O = (o._s.set(a, m), o._e.run(() => (r = R.effectScope()).run(() => t()))); for (const g in O) { const P = O[g]; if (R.isRef(P) && (!R.isRef($ = P) || !$.effect) || R.isReactive(P)) i || (!d || ($ = P, R.isVue2 ? T.has($) : w($) && $.hasOwnProperty(M)) || (R.isRef(P) ? P.value = d[g] : A(P, d[g])), R.isVue2 ? R.set(o.state.value[a], g, P) : o.state.value[a][g] = P); else if ("function" == typeof P) { const a = _(g, P); R.isVue2 ? R.set(O, g, a) : O[g] = a, s.actions[g] = P } } return R.isVue2 ? Object.keys(O).forEach(t => { R.set(m, t, O[t]) }) : (I(m, O), I(R.toRaw(m), O)), Object.defineProperty(m, "$state", { get: () => o.state.value[a], set: e => { v(t => { I(t, e) }) } }), R.isVue2 && (m._r = !0), o._p.forEach(t => { I(m, r.run(() => t({ store: m, app: o._a, pinia: o, options: s }))) }), d && i && e.hydrate && e.hydrate(m.$state, d), u = !0, p = !0, m } let i = "Store"; function t(i, r) { return Array.isArray(r) ? r.reduce((t, e) => (t[e] = function () { return i(this.$pinia)[e] }, t), {}) : Object.keys(r).reduce((t, n) => (t[n] = function () { const t = i(this.$pinia), e = r[n]; return "function" == typeof e ? e.call(this, t) : t[e] }, t), {}) } var e = t; return g.PiniaVuePlugin = function (t) { t.mixin({ beforeCreate() { const e = this.$options; if (e.pinia) { const t = e.pinia; if (!this._provided) { const e = {}; Object.defineProperty(this, "_provided", { get: () => e, set: t => Object.assign(e, t) }) } this._provided[d] = t, this.$pinia || (this.$pinia = t), t._a = this, n && P(t) } else !this.$pinia && e.parent && e.parent.$pinia && (this.$pinia = e.parent.$pinia) }, destroyed() { delete this._pStores } }) }, g.acceptHMRUpdate = function (t, e) { return () => { } }, g.createPinia = function () { const t = R.effectScope(!0), e = t.run(() => R.ref({})); let n = [], i = []; const r = R.markRaw({ install(t) { P(r), R.isVue2 || ((r._a = t).provide(d, r), t.config.globalProperties.$pinia = r, i.forEach(t => n.push(t)), i = []) }, use(t) { return (this._a || R.isVue2 ? n : i).push(t), this }, _p: n, _a: null, _e: t, _s: new Map, state: e }); return r }, g.defineStore = function (t, u, e) { let p, f; const h = "function" == typeof u; function n(e, t) { var n = R.getCurrentInstance(); if ((e = e || n && R.inject(d)) && P(e), !(e = l)._s.has(p)) if (h) y(p, u, f, e); else { var i = p, r = (n = f, e); const { state: s, actions: a, getters: o } = n, c = r.state.value[i]; let t; (t = y(i, function () { c || (R.isVue2 ? R.set(r.state.value, i, s ? s() : {}) : r.state.value[i] = s ? s() : {}); var t = R.toRefs(r.state.value[i]); return I(t, a, Object.keys(o || {}).reduce((t, e) => (t[e] = R.markRaw(R.computed(() => { P(r); var t = r._s.get(i); if (!R.isVue2 || t._r) return o[e].call(t, t) })), t), {})) }, n, r, 0, !0)).$reset = function () { const e = s ? s() : {}; this.$patch(t => { I(t, e) }) } } return e._s.get(p) } return "string" == typeof t ? (p = t, f = h ? e : u) : (f = t, p = t.id), n.$id = p, n }, g.getActivePinia = () => R.getCurrentInstance() && R.inject(d) || l, g.mapActions = function (n, i) { return Array.isArray(i) ? i.reduce((t, e) => (t[e] = function (...t) { return n(this.$pinia)[e](...t) }, t), {}) : Object.keys(i).reduce((t, e) => (t[e] = function (...t) { return n(this.$pinia)[i[e]](...t) }, t), {}) }, g.mapGetters = e, g.mapState = t, g.mapStores = function (...t) { return t.reduce((t, e) => (t[e.$id + i] = function () { return e(this.$pinia) }, t), {}) }, g.mapWritableState = function (n, i) { return Array.isArray(i) ? i.reduce((t, e) => (t[e] = { get() { return n(this.$pinia)[e] }, set(t) { return n(this.$pinia)[e] = t } }, t), {}) : Object.keys(i).reduce((t, e) => (t[e] = { get() { return n(this.$pinia)[i[e]] }, set(t) { return n(this.$pinia)[i[e]] = t } }, t), {}) }, g.setActivePinia = P, g.setMapStoreSuffix = function (t) { i = t }, g.skipHydrate = function (t) { return R.isVue2 ? T.set(t, 1) && t : Object.defineProperty(t, M, {}) }, g.storeToRefs = function (t) { if (R.isVue2) return R.toRefs(t); { const n = {}; for (const i in t = R.toRaw(t)) { var e = t[i]; (R.isRef(e) || R.isReactive(e)) && (n[i] = R.toRef(t, i)) } return n } }, Object.defineProperty(g, "__esModule", { value: !0 }), g }({}, VueDemi);